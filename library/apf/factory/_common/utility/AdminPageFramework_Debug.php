<?php 
/**
	Admin Page Framework v3.8.9b01 by Michael Uno 
	Generated by PHP Class Files Script Generator <https://github.com/michaeluno/PHP-Class-Files-Script-Generator>
	<http://en.michaeluno.jp/admin-page-framework>
	Copyright (c) 2013-2016, Michael Uno; Licensed under MIT <http://opensource.org/licenses/MIT> */
class AdminPageFramework_Debug extends AdminPageFramework_FrameworkUtility {
    static public function dump($asArray, $sFilePath = null) {
        echo self::get($asArray, $sFilePath);
    }
    static public function dumpArray($asArray, $sFilePath = null) {
        self::dump($asArray, $sFilePath);
    }
    static public function get($asArray, $sFilePath = null, $bEscape = true) {
        if ($sFilePath) {
            self::log($asArray, $sFilePath);
        }
        return $bEscape ? "<pre class='dump-array'>" . htmlspecialchars(self::getAsString($asArray)) . "</pre>" : self::getAsString($asArray);
    }
    static public function getArray($asArray, $sFilePath = null, $bEscape = true) {
        self::showDeprecationNotice(__CLASS__ . '::' . __FUNCTION__, __CLASS__ . '::get()');
        return self::get($asArray, $sFilePath, $bEscape);
    }
    static public function log($mValue, $sFilePath = null) {
        static $_fPreviousTimeStamp = 0;
        $_oCallerInfo = debug_backtrace();
        $_sCallerFunction = self::getElement($_oCallerInfo, array(1, 'function'), '');
        $_sCallerClass = self::getElement($_oCallerInfo, array(1, 'class'), '');
        $_fCurrentTimeStamp = microtime(true);
        file_put_contents(self::_getLogFilePath($sFilePath, $_sCallerClass), self::_getLogHeadingLine($_fCurrentTimeStamp, round($_fCurrentTimeStamp - $_fPreviousTimeStamp, 3), $_sCallerClass, $_sCallerFunction) . PHP_EOL . self::_getLogContents($mValue), FILE_APPEND);
        $_fPreviousTimeStamp = $_fCurrentTimeStamp;
    }
    static private function _getLogFilePath($bsFilePath, $sCallerClass) {
        $_bFileExists = self::_createFile($bsFilePath);
        if ($_bFileExists) {
            return $bsFilePath;
        }
        if (true === $bsFilePath) {
            return WP_CONTENT_DIR . DIRECTORY_SEPARATOR . basename(get_class()) . '_' . date("Ymd") . '.log';
        }
        return WP_CONTENT_DIR . DIRECTORY_SEPARATOR . basename(get_class()) . '_' . basename($sCallerClass) . '_' . date("Ymd") . '.log';
    }
    static private function _createFile($sFilePath) {
        if (!$sFilePath || true === $sFilePath) {
            return false;
        }
        if (file_exists($sFilePath)) {
            return true;
        }
        $_bhResrouce = fopen($sFilePath, 'w');
        return ( boolean )$_bhResrouce;
    }
    static private function _getLogContents($mValue) {
        $_sType = gettype($mValue);
        $_iLengths = self::_getValueLength($mValue, $_sType);
        return '(' . $_sType . (null !== $_iLengths ? ', length: ' . $_iLengths : '') . ') ' . self::getAsString($mValue) . PHP_EOL . PHP_EOL;
    }
    static private function _getValueLength($mValue, $sVariableType) {
        if (in_array($sVariableType, array('string', 'integer'))) {
            return strlen($mValue);
        }
        if ('array' === $sVariableType) {
            return count($mValue);
        }
        return null;
    }
    static private function _getLogHeadingLine($fCurrentTimeStamp, $nElapsed, $sCallerClass, $sCallerFunction) {
        static $_iPageLoadID;
        static $_nGMTOffset;
        $_nGMTOffset = isset($_nGMTOffset) ? $_nGMTOffset : get_option('gmt_offset');
        $_iPageLoadID = $_iPageLoadID ? $_iPageLoadID : uniqid();
        $_nNow = $fCurrentTimeStamp + ($_nGMTOffset * 60 * 60);
        $_nMicroseconds = str_pad(round(($_nNow - floor($_nNow)) * 10000), 4, '0');
        $_aOutput = array(date("Y/m/d H:i:s", $_nNow) . '.' . $_nMicroseconds, self::_getFormattedElapsedTime($nElapsed), $_iPageLoadID, AdminPageFramework_Registry::getVersion(), $sCallerClass . '::' . $sCallerFunction, current_filter(), self::getCurrentURL(),);
        return implode(' ', $_aOutput);
    }
    static private function _getFormattedElapsedTime($nElapsed) {
        $_aElapsedParts = explode(".", ( string )$nElapsed);
        $_sElapsedFloat = str_pad(self::getElement($_aElapsedParts, 1, 0), 3, '0');
        $_sElapsed = self::getElement($_aElapsedParts, 0, 0);
        $_sElapsed = strlen($_sElapsed) > 1 ? '+' . substr($_sElapsed, -1, 2) : ' ' . $_sElapsed;
        return $_sElapsed . '.' . $_sElapsedFloat;
    }
    static public function logArray($asArray, $sFilePath = null) {
        self::showDeprecationNotice(__CLASS__ . '::' . __FUNCTION__, __CLASS__ . '::log()');
        self::log($asArray, $sFilePath);
    }
    static public function getAsString($mValue) {
        $mValue = self::_getLegibleObject($mValue);
        $mValue = self::_getLegibleCallable($mValue);
        $mValue = self::_getLegibleArray($mValue);
        return print_r($mValue, true);
    }
    static private function _getLegibleCallable($asoCallable) {
        if (!is_callable($asoCallable)) {
            return $asoCallable;
        }
        if (is_string($asoCallable)) {
            return '(callable) ' . $asoCallable;
        }
        if (is_object($asoCallable)) {
            return '(callable) ' . get_class($asoCallable);
        }
        $_sSubject = is_object($asoCallable[0]) ? get_class($asoCallable[0]) : ( string )$asoCallable[0];
        return '(callable) ' . $_sSubject . '::' . ( string )$asoCallable[1];
    }
    static public function _getLegibleObject($oObject) {
        if (!is_object($oObject)) {
            return $oObject;
        }
        if (method_exists($oObject, '__toString')) {
            return ( string )$oObject;
        }
        return '(object) ' . get_class($oObject) . ' ' . count(get_object_vars($oObject)) . ' properties.';
    }
    static public function _getLegibleArray($aArray) {
        if (!is_array($aArray)) {
            return $aArray;
        }
        return self::_getArrayMappedRecursive(self::getSliceByDepth($aArray, 10), array(__CLASS__, '_getLegibleValue'));
    }
    static public function getSliceByDepth(array $aSubject, $iDepth = 0) {
        foreach ($aSubject as $_sKey => $_vValue) {
            if (is_array($_vValue)) {
                $_iDepth = $iDepth;
                if ($iDepth > 0) {
                    $aSubject[$_sKey] = self::getSliceByDepth($_vValue, --$iDepth);
                    $iDepth = $_iDepth;
                    continue;
                }
                unset($aSubject[$_sKey]);
            }
        }
        return $aSubject;
    }
    static private function _getLegibleValue($mItem) {
        if (is_object($mItem)) {
            return '(object) ' . get_class($mItem);
        }
        if (is_null($mItem)) {
            return '(null)';
        }
        if (is_bool($mItem)) {
            return '(boolean) ' . ($mItem ? 'true' : 'false');
        }
        return self::_getLegibleString($mItem);
    }
    static private function _getLegibleString($sScalar, $iCharLimit = 300) {
        static $_iMBSupport;
        $_iMBSupport = isset($_iMBSupport) ? $_iMBSupport : function_exists('mb_strlen');
        $_aStrLenMethod = array('strlen', 'mb_strlen');
        $_aSubstrMethod = array('substr', 'mb_substr');
        $_iCharLength = call_user_func_array($_aStrLenMethod[$_iMBSupport], array($sScalar));
        if ($_iCharLength <= $iCharLimit) {
            return '(' . gettype($sScalar) . ') ' . $sScalar;
        }
        return '(' . gettype($sScalar) . ') ' . call_user_func_array($_aSubstrMethod[$_iMBSupport], array($sScalar, 0, $iCharLimit)) . '...';
    }
    static private function _getArrayMappedRecursive(array $aArray, $oCallable) {
        self::$oCurrentCallable = $oCallable;
        $_aArray = array_map(array(__CLASS__, '_getArrayMappedNested'), $aArray);
        self::$oCurrentCallable = null;
        return $_aArray;
    }
    static public $oCurrentCallable;
    static private function _getArrayMappedNested($mItem) {
        return is_array($mItem) ? array_map(array(__CLASS__, '_getArrayMappedNested'), $mItem) : call_user_func(self::$oCurrentCallable, $mItem);
    }
}
